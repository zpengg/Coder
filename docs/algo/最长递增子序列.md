# 300 最长递增子序列
## 题目
[NO.300](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

最长递增子序列（Longest Increasing Subsequence，简写 LIS）

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

## 相关概念
 - LIS
 - [[动态规划]]
 - [[贪心]]
 - [[二分查抄]]

## 思路
1. 目标：LIS 长度

2. dp 一维还是二维？先忽略

3. 状态转移，没有 dp 也不是很好写。

那就停下来，暴力分析

Example: [ 0 3 1 6 2 2 7 ]
从左边开始，发觉可以直接写结果出来
已知：
单个数字，LIS 最小都为 1 （base）。
阻个数字分析
0: 1
3: 3>0, 组成 03 长度为 2
1: 1>0， 1<3, 组成 01，长度也为 2

**细分思考过程**：
![](http://zpengg.oss-cn-shenzhen.aliyuncs.com/img/1608176351eb1259.png)

思考两个问题：
1. 为什么可以这样比较？
2. dp[] 记录的是什么

看推导过程，我们容易陷入一下**错误**
> [!Attention]
> ❌ 第 i 个数字对应的 是 nums[0~i] 时的 LIS 的长度 
> ❌ 单向递增

新增 1 个数字 nums[j+1]
我们会与前边的每位数字结尾的字符串组合，若前一个数字 nums[j] 比 nums[j+1] 小，才满足严格递增
```
temp =  l（以 j 结尾的 子序列）+ 1
```
不满足严格递增不需要比较。

此时我们可以解答上面两个问题了
> [!info]
> dp[i] 含义： 以第 i 个数字结尾的 LIS 长度
> 在此基础上，新加数字若比前面数字大，则 LIS 至少增加 1，然后再看前面每一位哪位产生的新 LIS 最长
> 另外，dp[] 不是单向递增的，nums[0,nums.length-1] 的 LIS 可能在任何一位中出现。

所以最后，还要再比较以其他数字结尾的子序列，取最大值。

```
// 伪代码 
int l = nums.length;
for(int j=0; j<l-1; j++){
    int temp = 1; // 新增字母本身，LIS 至少长度为 1
    for (int k=0; k<=j; k++){
        if(nums[j+1] > nums[k]){ 
            dp[j+1] = max(temp,dp[k]);
        }
    }
}

int res = max(dp)
```
### 贪心+二分
核心思想：
1. **贪心**让序列上升尽可能慢
2. 复用空间 记录最长 序列。 在最长序列中 **二分查找**一个合适位置 放新的小元素 直至替换 保证序列递增。同时记录长度

## code
### dp 代码
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int l = nums.length;
        int[] dp = new int[l];
        dp[0] =1;
        for(int i= 1; i<l; i++){
            int res = 1;
            for(int j =0; j<i; j++){
                if(nums[i] > nums[j]){
                    res = Math.max(res, dp[j]+1);
                }
            }
            dp[i] = res;
        }

        int res = 0;
        for(int i = 0; i< l; i++){
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

## 复杂度
| 复杂度    | 时间     | 空间 |
|-----------|----------|------|
| dp        | O(n^2)   | O(n) |
| 贪心+二分 | O(nlogn) | O(n) |

## 坑点
1. 之前做几道 dp，惯性以为直接存目标值。
如果以上来就存 LIS，dp 更新中的比较逻辑是错误的。相互间不能
