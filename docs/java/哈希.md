# 哈希

## 哈希函数

### 直接定址法
f(key) = a × key + b
年份等: 2020 -> 20

### mod
f(key) = key mod p
当P取小于哈希表长的最大质数时，产生的哈希函数较好。我选97，因为它是离长度值最近的最大质数。

会冲突

> [!Attention]
> 冲突较多， 怎样解决？
 - 开放定址
 - 拉链法,hashmap实现

### 开放定址
所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

引入问题： 堆积(无冲突变冲突)

#### 线性探测: 找隔壁空位放
找隔壁空位放 直到有空位
```
fi(key) = (f(key)+di) MOD m (di=1,2,3,......,m-1)
```

#### 二次探测法： 双向找隔壁
双向
```
fi(key) = (f(key)+di) MOD m (di = 12, -12, 22, -22,……, q2, -q2, q <= m/2)
```


#### 伪随机探测： 找隔壁伪随机间隔位置
伪随机数列
```
fi(key) = (f(key)+di) MOD m (di是一个随机数列)
```

### 拉链法： 数组 + 链表
[[HashMap]]

特点：
不会堆积
性能换简单处理冲突
装载因子
容易删除
额外空间，


## 桶概念
特定场景 固定桶数 可以增加性能
比如存放 IP 地址的 hash table，用一个 65536 的桶就很好，把 IP 的后 16bit 作为 key。这种方法绝对比 hash_long、jhash 等函数的碰撞率低。 

## 单向散列算法
通过单向散列算法几乎不可能通过哈希值来唯一的确定输入，应用：加密安全，签名等
Md5 sha1