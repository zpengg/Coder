# G1
G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能

## 使命
停顿时间短，只回收价值大的分区，比CMS 全old 扫描 有优势，目标是替代 CMS

## 物理不隔离，独立回收
G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

## 分区 region 和 卡片 card
内存回收以分区为单位
对象分配以Card 为单位

### Humongous Region 巨型对象
可能占用多个分区，无法使用lab
分配时要扫描整堆 STW
成本高

## Remembered set
用于可达性分析， 跨分区应用
自家region 被外面对象引用的情况 
在数据量不同的时候采用不同的结构。
### cardtable
但分区里的对象还是要用 cardtable 来定位

young region -> old cardTable -> old obj

### PRT
Per Region Table(PRT)记录分区的引用情况
RSet 内部

## 三色标记（并发标记）
CMS 也是这个

### 漏标问题
产生漏标问题的条件有两个： 黑色对象指向了白色对象 灰色对象指向白色对象的引用消失
### 解决漏标问题
灰到白消失 && 黑到白增加

避免，打破两个条件之一即可： 
 - 跟踪黑指向白的增加 incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。 
 - 记录灰指向白的消失 SATB snapshot at the beginning：关注引用的删除，当灰–>白消失时，要把这个引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。

### SATB 与 Rset



## 过程
初始标记
并发标记

最终标记: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。

筛选回收: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

## 
空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器
从局部(两个 Region 之间)上来看是基于“复制”算法实现的，
这意味着运行期间不会产生内存空间碎片。


## 混合原因
为什么要有混合模式，而不是 Old 模式？

因为，Old 对象可能被 Young 区引用，这时 Young可能已经变成垃圾了，所以一起回收可能会释放更多的 Old 空间。