# 垃圾回收器


## 分类
- major/ full
- Minor
更常用分类
 - old, 只有 CMS 有
 - young
 - full
### young
copy
### old
mark sweep compact

### Full
整个heap以及perm gen，所有内存，全部的统一使用 old gen的收集器(一般是mark-sweep-compact算法) 一站式搞定
compact 到 old区

## CMS
- 对CPU资源非常敏感。
- 无法处理浮动垃圾，可能出现Concurrent Model Failure失败而导致另一次Full GC的产生。
- 因为采用标记-清除算法所以会存在空间碎片的问题，导致大对象无法分配空间，不得不提前触发一次Full GC。
### concurrent mode failure
serial old  兜底
CMSScavengeBeforeRemark remark阶段可以申请 YGC

## 组合
1. Serial GC算法
`Serial Young GC ＋ Serial Old GC `
实际上`Serial Old GC` 它是全局范围的`Full GC`

2. Parallel GC算法
`PS Marksweep GC ＋ PSMarkSweep / Parallel Old G`
这俩 old 实际上也是全局范围的`Full GC`
选PSMarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制
PS: Parallel Scavenge 吞吐量优先”收集器, GCTimeRatio
PSMarkSweep实质是 Mark-Compact

3. CMS算法：
`ParNew（Young）GC + CMS（Old）GC ＋ Full GC for CMS算法`
`CMS（old）`: 单独回收Old 区， piggyback on ParNew的结果／老生代存活下来的object只做记录，不做compaction）
`FULL`: 应对核心的CMS GC某些时候的不赶趟，开销很大）

4. G1 GC：
`Young GC + mixed GC＋ Full GC for G1 GC算法`
`mixed`: 新生代，再加上部分老生代
`FULL`：应对G1 GC算法某些时候的不赶趟，开销很大

## 触发条件
简单说，触发条件就是某GC算法对应区域满了，或是预测快满了。

### young
 - `Young GC`的触发原因： **eden区满了**
### old
 - `Serial Old GC／PS MarkSweep GC／Parallel Old GC` 的触发则是在要执行`Young GC`时候预测其promote的object的总size超过老生代剩余size；
 - `CMS GC`的initial marking的触发条件是 **老生代使用比率**超过某值；
 - `G1 GC`的initial marking的触发条件是 **Heap使用比率**超过某值，跟`CMS`heuristics 类似；

### full
 -  `Full GC for CMS`和`Full GC for G1 GC`: old的fancy算法不赶趟.
 - 碎片多
 - perm gen 满
 - System.gc()
 
#### full 之前有 young ？
PS MarkSweep GC／Parallel Old GC（Full GC）之前会跑一次Parallel Young GC；
以期降低full GC的暂停时长, 

参考:

作者：Ted Mosby
链接：https://www.zhihu.com/question/41922036/answer/144566789
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。