# Redis的过期策略

## 定期删除
定时检查 部分key

## 惰性
访问到才判断

举个简单的例子：中学的时候，平时作业太多，根本做不完，老师说下节课要讲这个卷子，你们都做完了吧？其实有很多人没做完，所以需要在下节课之前赶紧补上。

惰性删除也是这个道理，我们的这个值按理说应该没了，但是它还在，当你要获取这个key的时候，发现这个key应该过期了，赶紧删了，然后返回一个'没有这个值，已经过期了!'。

现在我们有了定期删除 + 惰性删除的过期策略，就可以高枕无忧了吗？并不是这样的，如果这个key一直不访问，那么它会一直滞留，也是不合理的，这就需要我们的内存淘汰机制了。 

## 主动淘汰策略
定期+惰性都没清理， 内存又快爆了

<div align="center"> <img src="http://zpengg.oss-cn-shenzhen.aliyuncs.com/img/40ee61563a5b1fc8e789019a7ed11e84.png"/> </div>

清理过程是阻塞的，
样本池抽样